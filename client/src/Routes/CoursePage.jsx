/*stil need to work on it*/
import React, { useState, useEffect } from "react";
import axios from "../api/axios";
import { useParams, useNavigate } from "react-router-dom";
import { toast } from "react-toastify";
import 'react-confirm-alert/src/react-confirm-alert.css';
import { useAuth } from "../context/authContext";
import ConfirmDialog from "../components/ConfirmationComponent";
 import { useCourseData } from "../context/CourseContext";
// Components
import CourseCard from "../components/coursePageComponents/CourseCard";
import Comment from "../components/coursePageComponents/Comment";
import FilterControls from "../components/coursePageComponents/FilterControls";
import Pagination from "../components/Pagination";

const CoursePage = () => {
  // Hooks
  const { courseId } = useParams();
  const navigate = useNavigate();
  const { user } = useAuth();
  const { deleteCourseFromContext } = useCourseData(); //To update the fetched course data used in the search bar and courses page

  // State
  const [course, setCourse] = useState(null);
  const [comments, setComments] = useState([]);
  const [filterTag, setFilterTag] = useState("");
  const [sortBy, setSortBy] = useState("recent");
  const [currentPage, setCurrentPage] = useState(1);
  const [searchQuery, setSearchQuery] = useState("");
  const [isConfirmOpen, setIsConfirmOpen] = useState(false); 
  const commentsPerPage = 8;

  // API Calls
  const fetchCourse = async () => {
    try {
      const response = await axios.get(`auth/course/${courseId}`);
      if (response.status === 200) {
        setCourse(response.data.course[0]);
        return true;
      }
    } catch (error) {
      if (error.response?.status === 404) {
        console.error("Error fetching course:", error);
      setCourse(null);
        toast.error("Ø§Ù„Ù…Ù‚Ø±Ø± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯");
       // navigate("/home");
       setTimeout(() => {navigate("/home"); console.log("test")}, 0); // Defer navigation
        return false;
      }
    }
  };
  // Handler for when course is rated or graded
  const handleCourseUpdate = async () => {
    await fetchCourse();
  };
  
  const fetchComments = async () => {
    try {
      const response = await axios.get(`auth/comments/${courseId}`);
      if (response.status === 200) {
        setComments(response.data.comments);
      }
    } catch (error) {
      if (error.response?.status === 404) {
        toast.info("Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ¹Ù„ÙŠÙ‚Ø§Øª Ø¹Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ù…Ù‚Ø±Ø± Ø¨Ø¹Ø¯");
        setComments([]);
      }
      // Todo :Razouq:  we dont show an error msg to the user here !
      console.error("Error fetching comments:", error);
    }
  };

  // Event Handlers
  const deleteCourse = async () => {
    try {
      const response = await axios.delete(`admin/deleteCourse/${courseId}`);
      if (response.status === 200) {
        toast.success('ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ù‚Ø±Ø± Ø¨Ù†Ø¬Ø§Ø­');
        deleteCourseFromContext(courseId); // Update the courses data (used in the search bar and the courses pageF)
        navigate("/home");
      }
    } catch (error) {
      toast.error('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„Ù…Ù‚Ø±Ø±');
      console.error('Error deleting course:', error);
    } finally {
      setIsConfirmOpen(false);
      
    }
  };
  
  // Effects
  useEffect(() => {
    let mounted = true; // when we use strictmode in react to perform useeffect twice so i use mounted to track if the
   // console.log("mounted1:",mounted)
    const loadData = async () => {
      if (mounted) {
       // console.log("mounted2:",mounted)
        const courseResult = await fetchCourse(); // after fetch the course unmount happen i do not no why but for now it is work fine
      //  console.log("mounted3:",mounted)
    //    console.log("corses fetched")
        if (courseResult !== false && mounted ) {
      //    console.log("mounted4:",mounted)
      //    console.log("comment fetched")
          await fetchComments();
        }
      }
    };
    
    loadData();
    //console.log("mounted5:",mounted)
    return () => { 
      mounted = false;
    };
  }, [courseId]);

  //  handle page reset when number of comments changes
  // ? Razouq: gauys! amazing work ! I have only one note here, It's recomended to write the useEffect just before the return statment ðŸ¤— We can agree on that then move all of them âœ…
  useEffect(() => {
    const totalPages = Math.ceil(
      // ? Razouq: shave my mustache if the most of this component isn't generated by AI
      filteredAndSortedComments.length / commentsPerPage
    );
    if (currentPage > totalPages) {
      setCurrentPage(Math.max(1, totalPages));
    }
  }, [filterTag, sortBy, searchQuery, comments]);

  /**
   * Filters and sorts an array of comments based on search query, tag, and sort criteria.
   *
   * notes all params are states above this function so we can not use this function in other file
   * @param {Array} comments - The array of comment objects to be filtered and sorted.
   * @param {string} searchQuery - The search query to filter comments by content.
   * @param {string} filterTag - The tag to filter comments by. If not provided, all tags are included.
   * @param {string} sortBy - The criteria to sort comments by. Can be "recent", "mostLikes", or "mostReplies".
   * @returns {Array} - The filtered and sorted array of comments.
   */
  const filteredAndSortedComments = comments
    .filter((comment) =>
      comment.content.toLowerCase().includes(searchQuery.toLowerCase())
    )
    .filter((comment) => (filterTag ? comment.tag === filterTag : true))
    .sort((a, b) => {
      if (sortBy === "recent")
        return new Date(b.creationDate) - new Date(a.creationDate);
      if (sortBy === "mostLikes") return b.numOfLikes - a.numOfLikes;
      if (sortBy === "mostReplies") return b.numOfReplies - a.numOfReplies;
      return 0;
    });

  // Pagination calculations
  const currentComments = filteredAndSortedComments.slice(
    (currentPage - 1) * commentsPerPage,
    currentPage * commentsPerPage
  );

  const totalPages = Math.ceil(
    filteredAndSortedComments.length / commentsPerPage
  );

  return (
    <div className="bg-gradient-to-b from-TAF-200 via-white to-TAF-200 min-h-screen">
      <div className="w-auto mx-auto container p-4">
        <CourseCard 
          course={course} 
          isAdmin={user?.isAdmin} 
          onDelete={() => setIsConfirmOpen(true)} 
          onCourseUpdate={handleCourseUpdate}
        />
        <ConfirmDialog
          title="Ø­Ø°Ù Ø§Ù„Ù…Ù‚Ø±Ø±"
          message="Ù‡Ù„ Ø§Ù†Øª Ù…ØªØ£ÙƒØ¯ Ø¨Ø§Ù†Ùƒ ØªØ±ÙŠØ¯ Ø­Ø°Ù Ø§Ù„Ù…Ù‚Ø±Ø±ØŸ"
          onConfirm={deleteCourse}
          onCancel={() => setIsConfirmOpen(false)}
          isRTL={true}
          isOpen={isConfirmOpen}
        />
        <FilterControls
          searchQuery={searchQuery}
          setSearchQuery={setSearchQuery}
          filterTag={filterTag}
          setFilterTag={setFilterTag}
          sortBy={sortBy}
          setSortBy={setSortBy}
        />

        <div className="space-y-4">
          {currentComments.map((comment) => (
            <Comment key={comment.id} comment={comment} />
          ))}
        </div>

        <Pagination
          currentPage={currentPage}
          totalPages={totalPages}
          setCurrentPage={setCurrentPage}
        />
        
      </div>
    </div>
  );
};

export default CoursePage;
